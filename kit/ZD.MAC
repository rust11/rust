die$c=1
int$c=0
;	%build
;	macro	tmp:zd/obj:tmp:
;	macro	drs:mmg$t+tmp:zd/obj:tmp:zdx
;	link	tmp:zd/execute:tmp:zd.sys/nobitmap/map:tmp:zd
;	link	tmp:zdx/execute:tmp:zdx.sys/nobitmap/map:tmp:zdx
;	%end
;.if df mmg$t
;	tim$it = 1
;.endc


.MCALL	.MODULE
.MODULE	DD,VERSION=12,COMMENT=<DECtape II Handler>,AUDIT=YES

;                   COPYRIGHT (c) 1984,1985,1986 BY
;             DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                         ALL RIGHTS RESERVED.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
.SBTTL	CONDITIONAL ASSEMBLY SUMMARY
	.SBTTL	GENERAL COMMENTS
	.ENABL	LC
	.SBTTL	MACROS AND DEFINITIONS
	.MCALL	.DRDEF,	.MTPS,	.ASSUME	.ADDR
	.IIF NDF DD$PRI	DD$PRI	= 4
	.IIF NDF DDT$O	DDT$O	= 0
	.IIF NDF DD$CS2	DD$CS2	= 176510
	.IIF NDF DD$VC2	DD$VC2	= 310
	.DRDEF	DD,34,FILST$,512.,176500,300
	.IIF EQ MMG$T	.DRPTR
	.IIF NE MMG$T	.DRPTR	FETCH=*NO*
	.DREST	CLASS=DVC.DK
.IIF NDF EIS$I	EIS$I = MMG$T
.IIF EQ EIS$I	.MCALL	SOB
	CS$INT	=: 100
	CS$BRK	=: 1
	DDCNT	=: 8.
	DDNREG	=: 10.
	R$$NOP	=: 0
	R$$INT	=: 1
	R$$RED	=: 2
	R$$WRT	=: 3
	R$$POS	=: 5
	R$$END	=: 100
	R$CONT	=: 20
	R$INIT	=: 4
	R$DATA	=: 1
	R$MSG	=: 2
	R$MSIZ	=: 10.
	R$DSIZ	=: 128.
	KISAR1	=: 172342
SYSPTR	=:	54
	CONFG2	=:	370
		PROS$	=:	020000
SYSCHN	=:	17
.READ	=:	375
.WRITE	=:	375
..READ	=:	010
..WRIT	=:	011
	.SBTTL	INSTALLATION CODE
.ASECT
.IF	NE DDT$O
	.DRINS	DD,<DD$CS2>
.IFF
	.DRINS	DD
.ENDC
	BR	1$
				.ASSUME . EQ INSSYS
	BR	15$
1$:	MOV	@#SYSPTR,R0
	BIT	#PROS$,CONFG2(R0)
	BNE	2$
15$:	TST	(PC)+
2$:	SEC
	RETURN
BAREA:	.BYTE	SYSCHN,..READ
	.BLKW
	.BLKW
	.WORD	256.
	.WORD	0
O.RTR1:	CMP	R0,R3
	BHI	O.BAD
	MOV	R0,DRETRY
	BEQ	O.BAD
	BR	O.GOOD
O.SYWL:
	MOV	@SP,R0
	INC	R0
	CMPB	#BR/400,(R0)+
	BNE	O.BAD
	MOV	R0,@SP
	BR	O.BAD
.ASSUME	. LE 400,MESSAGE=<;Install area too big>
	.SBTTL	SET OPTIONS
	.DRSET	CSR,	160000,	O.CSR,	OCT
	.DRSET	VECTOR,	500,	O.VEC,	OCT
	.IF NE	DDT$O
	.DRSET	CSR2,	160000,	O.CSR2,	OCT
	.DRSET	VEC2,	500,	O.VEC2,	OCT
	.ENDC
	.DRSET	RETRY,	DDCNT,	O.RTRY,	NUM
	.IF NE ERL$G
	.DRSET	SUCCES,	-1,	O.SUCC,	NO
	.ENDC
	BTCSR	= <DDEND-DDSTRT> + <BOTCSR-DDBOOT> + 1000
O.RTRY:	BR	O.RTR1
O.CSR:	CMP	R0,R3
	BLO	O.BAD
	MOV	R0,INSCSR
	MOV	R0,DISCSR
	.ADDR	#BAREA+4,R1
	.ADDR	#1000,R2
	MOV	R2,(R1)
	MOV	#BTCSR/1000,-(R1)
	TST	-(R1)
	MOV	R0,R3
	MOV	R1,R0
	EMT	.READ
	BCS	O.BAD
	MOV	R3,<BTCSR&777>(R2)
	ADD	#4,<BTCSR&777>(R2)
	MOV	R1,R0
					.ASSUME ..READ+1 EQ ..WRIT
	INCB	1(R0)
	EMT	.WRITE
	BCS	O.SYWL
	MOV	R1,R0
					.ASSUME ..WRIT-1 EQ ..READ
	DECB	1(R0)
	MOV	#1,2(R0)
	EMT	.READ
	BCS	O.BAD
	.IF NE	DDT$O
	MOV	R3,SET$L1+2
	.ENDC
	.ADDR	#TICSRA,R1
	MOV	#2,R0
	MOV	R3,(R1)+
	ADD	R0,R3
	MOV	R3,(R1)+
	ADD	R0,R3
	MOV	R3,(R1)+
	ADD	R0,R3
	MOV	R3,@R1
O.GOOD:	TST	(PC)+
O.BAD:	SEC
	RETURN
O.VEC:	CMP	R0,R3
	BHIS	O.BAD
	BIT	#3,R0
	BNE	O.BAD
	MOV	R0,VECTAB
	TST	(R0)+
	.IF NE	DDT$O
	MOV	R0,SET$L2+2
	.ENDC
	.ADDR	#TIVECA,R1
	MOV	R0,(R1)+
	TST	(R0)+
	MOV	R0,VECTAB+6
	TST	(R0)+
	MOV	R0,@R1
	RETURN
	.IF NE	DDT$O
O.CSR2:	CMP	R0,R3
	BLO	O.BAD
	MOV	R0,SET$L3+2
	MOV	R0,DISCS2
	RETURN
O.VEC2:	CMP	R0,R3
	BHIS	O.BAD
	BIT	#3,R0
	BNE	O.BAD
	MOV	R0,VECTAB+14
	TST	(R0)+
	MOV	R0,SET$L4+2
	TST	(R0)+
	MOV	R0,VECTAB+22
	BR	O.GOOD
	.ENDC
	.IF NE ERL$G
O.SUCC:	MOV	#0,R3
N.SUCC:	MOV	R3,SCSFLG
					.ASSUME O.SUCC+4 EQ N.SUCC
	BR	O.GOOD
	.ENDC
.Assume	. LE 1000,MESSAGE=<;SET area too big>
	.SBTTL	START I/O ENTRY
	.DRBEG	DD
	CALL	STARIO
ERR1:	MOV	DDCQE,R4
				.ASSUME Q$BLKN-2 EQ Q$CSW
	BIS	#HDERR$,@-(R4)
	BR	PDEXIT
VECTAB:	.DRVTB	DD,DD$VEC,DDINT
	.DRVTB	,DD$VEC+4,DDINT
				.ASSUME .-DDSTRT LE 1000
	.IF NE	DDT$O
	.DRVTB	,DD$VC2,DDINT
	.DRVTB	,DD$VC2+4,DDINT
				.ASSUME .-DDSTRT LE 1000
	.ENDC
	.IF NE ERL$G
SCSFLG:	.WORD	0
				.ASSUME .-DDSTRT LE 1000
	.ENDC
	.SBTTL	DD VECTOR AND CSR ADDRESS LIST
TICSRA:	.WORD	DD$CSR
TIBFRA:	.WORD	DD$CSR+2
TOCSRA:	.WORD	DD$CSR+4
TOBFRA:	.WORD	DD$CSR+6
TIVECA:	.WORD	DD$VEC+2
TOVECA:	.WORD	DD$VEC+6
				.ASSUME .-DDSTRT LE 1000
	.SBTTL	INTERRUPT ENTRY
	.ENABL LSB
	BR	DDABRT
DDINT::	BCS	1$
	JSR	R5,@$INPTR
	 .WORD	^C<DD$PRI*^O40>&^O340
	CLR	(PC)+
FKFLG:	 .WORD	0
	JMP	@I$INTR
1$:	MOV	R4,-(SP)
	CALL	@I$INTR
	MOV	(SP)+,R4
	RTI
	.DSABL LSB
	.SBTTL	INTERRUPT EXIT
INIRTN:	BIS	#CS$INT,@TICSRA
	BR	INPRTN
OUTCHR:	MOV	R5,@TOBFRA
OUTRTN:
INPRTN:	MOV	(SP)+,I$INTR
INTRTN:	RETURN
	.SBTTL	COMPLETION EXIT
COMPLT:	BCS	ERR1
	.IF NE	ERL$G
	TST	FKFLG
	BNE	1$
	CALL	FORK
1$:	TST	SCSFLG
	BNE	PDEXIT
	MOV	#DD$COD*400+377,R4
	MOV	DDCQE,R5
	CALL	@$ELPTR
	.ENDC
PDEXIT:	.DRFIN	DD
	.SBTTL	FORK ROUTINE
FORK:	MOV	(SP)+,FKFLG
	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	FKFLG,-(SP)
	JSR	PC,@(SP)+
	MOV	(SP)+,R3
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	PC
	.SBTTL	DDABRT - ABORT ENTRY
DDABRT::BIC	#1,@TIVECA
	BIC	#1,@TOVECA
	.MTPS	#340
	BIC	#CS$INT,@TICSRA
	BIS	#CS$INT,@TOCSRA
	CLR	(PC)+
5$:	 .BLKW
10$:	MOV	#R$INIT,R5
	CALL	OUTCHR
	DECB	5$
	BEQ	15$
	TSTB	@TICSRA
	BPL	10$
	CALL	TXINIT
15$:	BR	PDEXIT
	.SBTTL	STARIO	- START I/O CODE
	.ENABL	LSB
STARIO::CLR	PK$UNT
	MOV	DDCQE,R3
	MOVB	Q$UNIT(R3),R0
	BIC	#^C<7>,R0
	ASR	R0
	.IF EQ	DDT$O
	BNE	10$
	.ENDC
	BCC	1$
	INC	PK$UNT
1$:
	.IF NE	DDT$O
SET$L1:	MOV	#DD$CSR,R3
SET$L2:	MOV	#DD$VEC+2,R2
				.ASSUME .-DDSTRT LE 1000
	ASR	R0
	BNE	10$
	BCC	2$
SET$L3:	MOV	#DD$CS2,R3
SET$L4:	MOV	#DD$VC2+2,R2
				.ASSUME .-DDSTRT LE 1000
2$:
	.ADDR	#TICSRA,R1
	CMP	R3,@R1
	BEQ	4$
	MOV	#4,R0
3$:	MOV	R3,(R1)+
	TST	(R3)+
	SOB	R0,3$
	MOV	R2,(R1)+
	CMP	(R2)+,(R2)+
	MOV	R2,@R1
4$:
	.ENDC
DRETRY	= .+2
	MOV	#DDCNT,I$ERCT
				.ASSUME .-DDSTRT LE 1000
	CLR	RETIO
	TST	I$ABRT
	BNE	RETRY
	.ADDR	#ABORT,R1
	BR	GO
RETRY:	MOV	DDCQE,R3
	TST	RETIO
	BEQ	7$
	ADD	#Q$WCNT,R3
	MOV	@R3,R1
	BPL	5$
	NEG	R1
5$:	ASL	R1
	SUB	I$BYTC,R1
	ROR	R1
	CLRB	R1
	MOV	R1,R2
	TST	@R3
	BPL	6$
	NEG	R1
6$:	SUB	R1,@R3
	.IF EQ	MMG$T
				.ASSUME Q$WCNT-2 EQ Q$BUFF
	ADD	R2,-(R3)
	ADD	R2,@R3
				.ASSUME Q$BUFF-2 EQ Q$FUNC
	TST	-(R3)
	.IFF
	MOV	R2,R1
	ASHC	#-5,R1
	ADD	R1,Q$PAR-Q$WCNT(R3)
				.ASSUME Q$WCNT-4 EQ Q$FUNC
	CMP	-(R3),-(R3)
	.ENDC
	SWAB	R2
				.ASSUME Q$FUNC-2 EQ Q$BLKN
	ADD	R2,-(R3)
7$:	MOV	#R$$RED,PK$OPC
	CLRB	PK$SSQ
	CLR	PK$SSQ+1
	MOV	Q$WCNT(R3),R1
	BPL	8$
	MOVB	#R$$WRT,PK$OPC
	NEG	R1
8$:	ASL	R1
	BNE	9$
	MOVB	#R$$POS,PK$OPC
9$:	MOV	Q$BUFF(R3),I$ADRS
	.IF NE	MMG$T
	MOV	Q$PAR(R3),I$PAR
	.ENDC
	MOV	R1,I$BYTC
	MOV	R1,PK$BCT
	MOV	@R3,PK$RCD
	.ADDR	#TXGO,R1
GO:	MOV	R1,I$INTR
	BIS	#CS$INT,@TOCSRA
	TST	(SP)+
10$:	RETURN
	.DSABL	LSB
	.SBTTL	TXGO	- START TRANSFER FROM INTERRUPT LEVEL
TXGO:	CALL	FORK
	MOV	#R$MSG,PK$FLG
	MOV	#R$MSIZ,R2
	.ADDR	#PK$OPC,R1
	CALL	SNDPKT
1$:	CMPB	PK$OPC,#R$$WRT
	BNE	2$
	JSR	R5,RCVPKT
	 .WORD	R$CONT
2$:	MOV	I$ADRS,R1
	MOV	I$BYTC,R2
	BEQ	TXEND
	CMP	R2,#R$DSIZ
	BLOS	3$
	MOV	#R$DSIZ,R2
3$:	CMPB	PK$OPC,#R$$WRT
	BNE	4$
	MOVB	#R$DATA,PK$FLG
	CALL	SNDPKT
	CMP	I$BYTC,#R$DSIZ
	BLOS	TXEND
	JSR	R5,RCVPKT
	 .WORD	R$CONT
	BR	5$
4$:	JSR	R5,RCVPKT
	 .WORD	R$DATA
5$:
	.IF EQ	MMG$T
	ADD	#R$DSIZ,I$ADRS
	.IFF
	ADD	#2,I$PAR
	.ENDC
	SUB	#R$DSIZ,I$BYTC
	BHI	2$
	CLR	I$BYTC
	.SBTTL	TXEND	- READ THE END PACKET AFTER A TRANSFER
TXEND:
	.ADDR	#I$MBFR,R1
	MOV	#R$MSIZ,R2
	JSR	R5,RCVPKT
	 .WORD	R$MSG
	.SBTTL	ERROR	- ANALYZE AN END PACKET
ERROR:	CMPB	PK$FLG,#R$MSG
	BNE	ABORTR
	CMPB	I$MOPC,#R$$END
	BNE	ABORTR
	TSTB	I$MSUC
	.IF EQ	ERL$G
	BPL	CPLRTN
	.IFF
	BEQ	CPLRTN
	BLT	FATAL
	MOV	I$ERCT,R2
	CALL	LOGERR
	BR	CPLRTN
	.ENDC
FATAL:	TST	FKFLG
	BNE	1$
	CALL	FORK
	.IF NE	ERL$G
	CLR	R2
	CALL	LOGERR
	.ENDC
1$:	SEC
CPLRTN:	BIC	R4,R4
	BIC	#CS$INT,@TICSRA
	BIC	#CS$INT,@TOCSRA
	JMP	COMPLT
	.SBTTL	ABORT	- COMMUNICATIONS ERROR
ABORTR:	MOV	SP,(PC)+
RETIO:	 .WORD	0
ABORT:	CALL	TXINIT
	CLR	I$ABRT
	TST	I$ERCT
	BLE	FATAL
	INC	I$ABRT
	MOV	R3,-(SP)
	MOV	R2,-(SP)
	MOV	R1,-(SP)
	MOV	R0,-(SP)
	CALL	9$
	MOV	(SP)+,R0
	MOV	(SP)+,R1
	MOV	(SP)+,R2
	MOV	(SP)+,R3
	RETURN
9$:	CALL	RETRY
	TST	(SP)+
	MOV	(SP)+,R0
	MOV	(SP)+,R1
	MOV	(SP)+,R2
	MOV	(SP)+,R3
	BR	FATAL
	.IF NE	ERL$G
.SBTTL LOGERR - SET UP AND CALL ERROR LOGGER
LOGERR:	MOV	R2,R4
	BIS	#DD$COD*400,R4
	MOV	DRETRY,R3
	SWAB	R3
	ADD	#DDNREG,R3
	.ADDR	#I$LCHR,R2
	MOV	DDCQE,R5
	CALL	@$ELPTR
	CLR	I$LCHR
	RETURN
	.ENDC
	.SBTTL	TXINIT	- INIT THE TU58
TXINIT:	BIC	#CS$INT,@TOCSRA
	BIC	#CS$INT,@TICSRA
	MOV	(SP)+,I$SUBR
1$:
	.IF NE	ERL$G
	TST	I$ABRT
	BEQ	2$
	TST	FKFLG
	BNE	3$
	CALL	FORK
3$:	MOV	I$ERCT,R2
	CALL	LOGERR
2$:
	.ENDC
	.MTPS	#340
	MOV	#177777,@TOBFRA
	BIS	#<CS$INT!CS$BRK>,@TOCSRA
	CALL	OUTRTN
	MOV	#177777,R5
	CALL	OUTCHR
	BIC	#CS$BRK,@TOCSRA
	MOV	#R$INIT,R5
	CALL	OUTCHR
	MOV	#R$INIT,R5
	CALL	OUTCHR
	BIC	#CS$INT,@TOCSRA
	TST	@TIBFRA
	CALL	INIRTN
	MOV	@TIBFRA,PK$FLG
	BIC	#CS$INT,@TICSRA
	DEC	I$ERCT
	BLE	9$
	CMPB	PK$FLG,#R$CONT
	BNE	1$
9$:	CALLR	@I$SUBR
	.SBTTL	SNDPKT	- SEND RADIAL SERIAL PACKET
SNDPKT:	MOV	(SP)+,I$SUBR
	MOV	R1,I$MADR
	MOVB	R2,PK$MBC
	MOV	PK$FLG,PK$CKS
	.MTPS	#340
	MOVB	PK$FLG,@TOBFRA
	BIS	#CS$INT,@TOCSRA
	CALL	OUTRTN
	MOVB	PK$MBC,R5
	CLRB	I$TDAT+1
.if eq int$c
	BIS	#1,@TOVECA
.endc
	CALL	OUTCHR
2$:
	.IF NE MMG$T
	MOV	@#KISAR1,-(SP)
	MOV	I$PAR,@#KISAR1
	.ENDC
	MOVB	@I$MADR,@TOBFRA
	MOVB	@I$MADR,I$TDAT
	.IF NE MMG$T
	MOV	(SP)+,@#KISAR1
	.ENDC
	INC	I$MADR
	ADD	I$TDAT,PK$CKS
	ADC	PK$CKS
	SWAB	PK$CKS
	DECB	PK$MBC
	BEQ	3$
	RETURN
3$:	BIC	#1,@TOVECA
	ADD	#4$-2$,I$INTR
	RETURN
4$:	MOVB	PK$CKS,R5
	CALL	OUTCHR
	MOVB	PK$CKS+1,R5
	CALL	OUTCHR
	BIC	#CS$INT,@TOCSRA
PKTRTN:	CALL	FORK
	CALLR	@I$SUBR
	.SBTTL	RCVPKT	- RECEIVE A RADIAL SERIAL PACKET
RCVPKT:	MOV	(R5)+,I$EFLG
	MOV	R5,I$SUBR
	MOV	(SP)+,R5
	MOV	R1,I$MADR
	.MTPS	#340
	CALL	INIRTN
	MOV	@TIBFRA,R4
	BMI	6$
	MOVB	R4,PK$FLG
	CMPB	R4,I$EFLG
	BEQ	2$
	CMPB	R4,#R$MSG
	BNE	6$
	.ADDR	#I$MBFR,-(SP)
	MOV	(SP)+,I$MADR
2$:	CMPB	R4,#R$CONT
	BEQ	PKTRTN
.if eq int$c
	BIS	#1,@TIVECA
.endc
	CALL	INPRTN
1$:
	MOV	@TIBFRA,R4
	BMI	8$
	MOVB	R4,PK$MBC
	MOV	PK$FLG,PK$CKS
	ADD	#4$-1$,I$INTR
3$:	RETURN
4$:	MOV	@TIBFRA,R4
	BMI	8$
.if ne die$c
	dec	(pc)+
100$:	.word	1000.
	bpl	120$
	mov	#1000.,100$
110$:	tstb	@#177564
	bpl	110$
	mov	#'@,@#177566
	br	8$
120$:
.endc
	.IF NE MMG$T
	MOV	@#KISAR1,-(SP)
	MOV	I$PAR,@#KISAR1
	.ENDC
	MOVB	R4,@I$MADR
	.IF NE MMG$T
	MOV	(SP)+,@#KISAR1
	.ENDC
	INC	I$MADR
	BIC	#^C<377>,R4
	ADD	PK$CKS,R4
	ADC	R4
	SWAB	R4
	MOV	R4,PK$CKS
	DECB	PK$MBC
	BNE	3$
	BIC	#1,@TIVECA
	ADD	#7$-4$,I$INTR
	RETURN
7$:	MOV	@TIBFRA,R4
	BMI	6$
	MOVB	R4,I$TDAT
	CALL	INPRTN
	MOV	@TIBFRA,R4
	BMI	6$
	MOVB	R4,I$TDAT+1
	BIC	#CS$INT,@TICSRA
	CMP	I$TDAT,PK$CKS
	BNE	5$
	CMPB	PK$FLG,I$EFLG
	BEQ	PKTRTN
	JMP	ERROR
6$:
	.IF NE	ERL$G
	MOV	R4,I$LCHR
	.ENDC
5$:	JMP	ABORTR
8$:
	.IF NE	ERL$G
	MOV	R4,I$LCHR
	.ENDC
	BIC	#1,@TIVECA
	.ADDR	#ABORTR,-(SP)
	MOV	(SP)+,I$INTR
	RETURN
	.SBTTL	DATA AREA
I$ABRT:	.WORD	0
I$ADRS:	.WORD	0
I$BYTC:	.WORD	0
I$INTR:	.WORD	0
I$ERCT:	.WORD	0
I$MADR:	.WORD	0
I$TDAT:	.WORD	0
I$SUBR:	.WORD	0
	.IF NE	ERL$G
I$LCHR:	.WORD	0
	.ENDC
I$EFLG:	.WORD	0
I$MBFR:
I$MOPC:	.BYTE	0
I$MSUC:	.BYTE	0
	.BYTE	0,0,0,0,0,0,0,0
	.IF NE	MMG$T
I$PAR:	.WORD	0
	.ENDC
PK$FLG:	.BYTE	0
PK$MBC:	.BYTE	0
PK$OPC:	.BYTE	0
PK$MOD:	.BYTE	0
PK$UNT:	.BYTE	0
PK$SSQ:	.BYTE	0,0,0
PK$BCT:	.BYTE	0,0
PK$RCD:	.BYTE	0,0
PK$CKS:	.BYTE	0,0
	.SBTTL	BOOTSTRAP READ ROUTINE
	.DRBOT	DD,BOOT1,READ
	. = DDBOOT+40
BOOT1:	JMP	@#BOOT-DDBOOT
	. = DDBOOT+210
READ:	MOV	#DDCNT,RTRCNT
	MOV	@#B$DEVU,DDUNIT
	ASL	R1
	MOV	R0,DDBLK
	MOV	R1,DDBTCT
BRESTR:	MOV	R2,-(SP)
	MOV	(PC)+,R0
BOTCSR:	 .WORD	DD$CSR+4
	BIS	#CS$BRK,@R0
	MOV	(PC)+,R3
	 .WORD	177777
	CALL	BCHROS
CONRD1:	TSTB	@R0
	BPL	CONRD1
	BIC	#CS$BRK,@R0
	MOV	(PC)+,R3
	 .BYTE	R$INIT,R$INIT
	CALL	BCHROS
	TST	-2(R0)
	CALL	BICHR
	CMPB	R3,#R$CONT
	BNE	BFATAL
	MOV	#B$CHK-DDBOOT,R4
	CLR	@R4
	MOV	#B$PKT-DDBOOT,R5
1$:	MOV	(R5)+,R3
	ADD	R3,@R4
	ADC	@R4
	CALL	BCHROS
	CMP	R5,R4
	BLOS	1$
BRDPKT:	CALL	BICHP2
	MOVB	R3,R4
	RORB	R4
	MOV	R1,-(SP)
	CMPB	R1,#R$DATA
	BNE	BEND
2$:	CALL	@R5
	MOV	R1,(R2)+
	ADD	R1,@SP
	ADC	@SP
	DECB	R4
	BGT	2$
	CALL	(R5)
	CMP	R1,(SP)+
	BNE	BFATAL
	BR	BRDPKT
BEND:	CALL	(R5)
	TSTB	R3
	BMI	BOTH
1$:	ADD	R1,@SP
	ADC	@SP
	CALL	(R5)
	SOB	R4,1$
	CMP	R1,(SP)+
	BNE	BFATAL
	MOV	(SP)+,R2
	CLC
	RETURN
BOTH:	TST	(SP)+
BFATAL:	MOV	(SP)+,R2
	DEC	RTRCNT
	BNE	BRESTR
	BR	BIOERR
	.SBTTL	BYTE INPUT ROUTINES (BOOT)
BICHP2:	MOV	PC,R5
	CLR	R1
	CALL	@PC
BICHR:	TSTB	-4(R0)
	BPL	BICHR
	MOVB	-2(R0),R3
	BISB	R3,R1
	SWAB	R1
	RETURN
	.SBTTL	BYTE OUTPUT ROUTINES (BOOT)
BCHROS:	CALL	@PC
1$:	TSTB	@R0
	BPL	1$
	MOVB	R3,2(R0)
	SWAB	R3
	RETURN
B$PKT:	.BYTE	R$MSG,R$MSIZ,R$$RED,0
DDUNIT:	.WORD	0
	.BYTE	0,0
DDBTCT:	.WORD	0
DDBLK:	.WORD	0
B$CHK:	.WORD	0
RTRCNT:	.WORD	0
	. = DDBOOT+606
BOOT:	MOV	#10000,SP
	MOV	R0,@#B$DEVU
	MOV	R0,-(SP)
	MOV	#2,R0
	MOV	#<4*400>,R1
	MOV	#1000,R2
	CALL	READ
	MOV	#READ-DDBOOT,@#B$READ
	MOV	#B$DNAM,@#B$DEVN
	MOV	(SP)+,@#B$DEVU
	JMP	@#B$BOOT
	.DREND	DD
	.END
                                           